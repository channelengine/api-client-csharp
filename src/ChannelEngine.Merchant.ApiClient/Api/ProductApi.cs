/* 
 * ChannelEngine Merchant API
 *
 * ChannelEngine API for merchants
 *
 * OpenAPI spec version: 2.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using ChannelEngine.Merchant.ApiClient.Client;
using ChannelEngine.Merchant.ApiClient.Model;

namespace ChannelEngine.Merchant.ApiClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IProductApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Upsert Products
        /// </summary>
        /// <remarks>
        /// Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>SingleOfProductCreationResult</returns>
        SingleOfProductCreationResult ProductCreate (List<MerchantProductRequest> products);

        /// <summary>
        /// Upsert Products
        /// </summary>
        /// <remarks>
        /// Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>ApiResponse of SingleOfProductCreationResult</returns>
        ApiResponse<SingleOfProductCreationResult> ProductCreateWithHttpInfo (List<MerchantProductRequest> products);
        /// <summary>
        /// Delete Product
        /// </summary>
        /// <remarks>
        /// Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>ApiResponse</returns>
        ApiResponse ProductDelete (string merchantProductNo);

        /// <summary>
        /// Delete Product
        /// </summary>
        /// <remarks>
        /// Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>ApiResponse of ApiResponse</returns>
        ApiResponse<ApiResponse> ProductDeleteWithHttpInfo (string merchantProductNo);
        /// <summary>
        /// Get Products
        /// </summary>
        /// <remarks>
        /// Retrieve all products
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>CollectionOfMerchantProductResponse</returns>
        CollectionOfMerchantProductResponse ProductGetByFilter (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null);

        /// <summary>
        /// Get Products
        /// </summary>
        /// <remarks>
        /// Retrieve all products
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>ApiResponse of CollectionOfMerchantProductResponse</returns>
        ApiResponse<CollectionOfMerchantProductResponse> ProductGetByFilterWithHttpInfo (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null);
        /// <summary>
        /// Get Product
        /// </summary>
        /// <remarks>
        /// Retrieve a product based on the merchant reference.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>SingleOfMerchantProductResponse</returns>
        SingleOfMerchantProductResponse ProductGetByMerchantProductNo (string merchantProductNo);

        /// <summary>
        /// Get Product
        /// </summary>
        /// <remarks>
        /// Retrieve a product based on the merchant reference.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>ApiResponse of SingleOfMerchantProductResponse</returns>
        ApiResponse<SingleOfMerchantProductResponse> ProductGetByMerchantProductNoWithHttpInfo (string merchantProductNo);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Upsert Products
        /// </summary>
        /// <remarks>
        /// Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>Task of SingleOfProductCreationResult</returns>
        System.Threading.Tasks.Task<SingleOfProductCreationResult> ProductCreateAsync (List<MerchantProductRequest> products);

        /// <summary>
        /// Upsert Products
        /// </summary>
        /// <remarks>
        /// Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>Task of ApiResponse (SingleOfProductCreationResult)</returns>
        System.Threading.Tasks.Task<ApiResponse<SingleOfProductCreationResult>> ProductCreateAsyncWithHttpInfo (List<MerchantProductRequest> products);
        /// <summary>
        /// Delete Product
        /// </summary>
        /// <remarks>
        /// Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse> ProductDeleteAsync (string merchantProductNo);

        /// <summary>
        /// Delete Product
        /// </summary>
        /// <remarks>
        /// Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of ApiResponse (ApiResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ApiResponse>> ProductDeleteAsyncWithHttpInfo (string merchantProductNo);
        /// <summary>
        /// Get Products
        /// </summary>
        /// <remarks>
        /// Retrieve all products
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>Task of CollectionOfMerchantProductResponse</returns>
        System.Threading.Tasks.Task<CollectionOfMerchantProductResponse> ProductGetByFilterAsync (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null);

        /// <summary>
        /// Get Products
        /// </summary>
        /// <remarks>
        /// Retrieve all products
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>Task of ApiResponse (CollectionOfMerchantProductResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<CollectionOfMerchantProductResponse>> ProductGetByFilterAsyncWithHttpInfo (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null);
        /// <summary>
        /// Get Product
        /// </summary>
        /// <remarks>
        /// Retrieve a product based on the merchant reference.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of SingleOfMerchantProductResponse</returns>
        System.Threading.Tasks.Task<SingleOfMerchantProductResponse> ProductGetByMerchantProductNoAsync (string merchantProductNo);

        /// <summary>
        /// Get Product
        /// </summary>
        /// <remarks>
        /// Retrieve a product based on the merchant reference.
        /// </remarks>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of ApiResponse (SingleOfMerchantProductResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<SingleOfMerchantProductResponse>> ProductGetByMerchantProductNoAsyncWithHttpInfo (string merchantProductNo);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ProductApi : IProductApi
    {
        private ChannelEngine.Merchant.ApiClient.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ProductApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ProductApi(String basePath)
        {
            this.Configuration = new ChannelEngine.Merchant.ApiClient.Client.Configuration { BasePath = basePath };

            ExceptionFactory = ChannelEngine.Merchant.ApiClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ProductApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ProductApi(ChannelEngine.Merchant.ApiClient.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = ChannelEngine.Merchant.ApiClient.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = ChannelEngine.Merchant.ApiClient.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public ChannelEngine.Merchant.ApiClient.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public ChannelEngine.Merchant.ApiClient.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Upsert Products Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>SingleOfProductCreationResult</returns>
        public SingleOfProductCreationResult ProductCreate (List<MerchantProductRequest> products)
        {
             ApiResponse<SingleOfProductCreationResult> localVarResponse = ProductCreateWithHttpInfo(products);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Upsert Products Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>ApiResponse of SingleOfProductCreationResult</returns>
        public ApiResponse< SingleOfProductCreationResult > ProductCreateWithHttpInfo (List<MerchantProductRequest> products)
        {
            // verify the required parameter 'products' is set
            if (products == null)
                throw new ApiException(400, "Missing required parameter 'products' when calling ProductApi->ProductCreate");

            var localVarPath = "/v2/products";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (products != null && products.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(products); // http body (model) parameter
            }
            else
            {
                localVarPostBody = products; // byte array
            }

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SingleOfProductCreationResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SingleOfProductCreationResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SingleOfProductCreationResult)));
        }

        /// <summary>
        /// Upsert Products Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>Task of SingleOfProductCreationResult</returns>
        public async System.Threading.Tasks.Task<SingleOfProductCreationResult> ProductCreateAsync (List<MerchantProductRequest> products)
        {
             ApiResponse<SingleOfProductCreationResult> localVarResponse = await ProductCreateAsyncWithHttpInfo(products);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Upsert Products Upsert (update or create) products. The parent serves as the &#39;base&#39; product of the children.  For example, the children could be different sizes or colors of the parent product.  For channels where every size and color are different products this does not make any difference  (the children will just be sent separately, while ignoring the parent).  But there are channels where the parent and the children need to be sent together, for example  when there is one product with a list of sizes. In this case all the product information is retrieved  from the parent product while the size list is generated from the children.    Note that the parent itself is a &#39;blueprint&#39; of the child products and we do our best to make sure it  does not end up on the marketplaces itself. Only the children can be purchased.    It&#39;s not possible to nest parent and children more than one level (A parent can have many children,  but any child cannot itself also have children).    The supplied MerchantProductNo needs to be unique.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="products"></param>
        /// <returns>Task of ApiResponse (SingleOfProductCreationResult)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SingleOfProductCreationResult>> ProductCreateAsyncWithHttpInfo (List<MerchantProductRequest> products)
        {
            // verify the required parameter 'products' is set
            if (products == null)
                throw new ApiException(400, "Missing required parameter 'products' when calling ProductApi->ProductCreate");

            var localVarPath = "/v2/products";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/json", 
                "text/json", 
                "application/_*+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (products != null && products.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(products); // http body (model) parameter
            }
            else
            {
                localVarPostBody = products; // byte array
            }

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductCreate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SingleOfProductCreationResult>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SingleOfProductCreationResult) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SingleOfProductCreationResult)));
        }

        /// <summary>
        /// Delete Product Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>ApiResponse</returns>
        public ApiResponse ProductDelete (string merchantProductNo)
        {
             ApiResponse<ApiResponse> localVarResponse = ProductDeleteWithHttpInfo(merchantProductNo);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete Product Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>ApiResponse of ApiResponse</returns>
        public ApiResponse< ApiResponse > ProductDeleteWithHttpInfo (string merchantProductNo)
        {
            // verify the required parameter 'merchantProductNo' is set
            if (merchantProductNo == null)
                throw new ApiException(400, "Missing required parameter 'merchantProductNo' when calling ProductApi->ProductDelete");

            var localVarPath = "/v2/products/{merchantProductNo}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (merchantProductNo != null) localVarPathParams.Add("merchantProductNo", this.Configuration.ApiClient.ParameterToString(merchantProductNo)); // path parameter

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ApiResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ApiResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ApiResponse)));
        }

        /// <summary>
        /// Delete Product Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse> ProductDeleteAsync (string merchantProductNo)
        {
             ApiResponse<ApiResponse> localVarResponse = await ProductDeleteAsyncWithHttpInfo(merchantProductNo);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete Product Delete a product based on the merchant reference.  Note that we do not really delete a product, as the product  might still be referenced by orders etc. Therefore, the references  used for this product cannot be reused. We do however deactivate the product  which means that it will not be sent to channels.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of ApiResponse (ApiResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ApiResponse>> ProductDeleteAsyncWithHttpInfo (string merchantProductNo)
        {
            // verify the required parameter 'merchantProductNo' is set
            if (merchantProductNo == null)
                throw new ApiException(400, "Missing required parameter 'merchantProductNo' when calling ProductApi->ProductDelete");

            var localVarPath = "/v2/products/{merchantProductNo}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (merchantProductNo != null) localVarPathParams.Add("merchantProductNo", this.Configuration.ApiClient.ParameterToString(merchantProductNo)); // path parameter

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductDelete", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ApiResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ApiResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(ApiResponse)));
        }

        /// <summary>
        /// Get Products Retrieve all products
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>CollectionOfMerchantProductResponse</returns>
        public CollectionOfMerchantProductResponse ProductGetByFilter (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null)
        {
             ApiResponse<CollectionOfMerchantProductResponse> localVarResponse = ProductGetByFilterWithHttpInfo(filterSearch, filterEanList, filterMerchantProductNoList, filterPage);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Products Retrieve all products
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>ApiResponse of CollectionOfMerchantProductResponse</returns>
        public ApiResponse< CollectionOfMerchantProductResponse > ProductGetByFilterWithHttpInfo (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null)
        {

            var localVarPath = "/v2/products";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter.search", filterSearch)); // query parameter
            if (filterEanList != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "filter.eanList", filterEanList)); // query parameter
            if (filterMerchantProductNoList != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "filter.merchantProductNoList", filterMerchantProductNoList)); // query parameter
            if (filterPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter.page", filterPage)); // query parameter

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductGetByFilter", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CollectionOfMerchantProductResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CollectionOfMerchantProductResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CollectionOfMerchantProductResponse)));
        }

        /// <summary>
        /// Get Products Retrieve all products
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>Task of CollectionOfMerchantProductResponse</returns>
        public async System.Threading.Tasks.Task<CollectionOfMerchantProductResponse> ProductGetByFilterAsync (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null)
        {
             ApiResponse<CollectionOfMerchantProductResponse> localVarResponse = await ProductGetByFilterAsyncWithHttpInfo(filterSearch, filterEanList, filterMerchantProductNoList, filterPage);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Products Retrieve all products
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Search product(s) by Name, MerchantProductNo, Ean or Brand      This search is applied to the result after applying the other filters. (optional)</param>
        /// <param name="filterEanList">Search products by submitting a list of EAN&#39;s (optional)</param>
        /// <param name="filterMerchantProductNoList">Search products by submitting a list of MerchantProductNo&#39;s (optional)</param>
        /// <param name="filterPage">The page to filter on. Starts at 1. (optional)</param>
        /// <returns>Task of ApiResponse (CollectionOfMerchantProductResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<CollectionOfMerchantProductResponse>> ProductGetByFilterAsyncWithHttpInfo (string filterSearch = null, List<string> filterEanList = null, List<string> filterMerchantProductNoList = null, int? filterPage = null)
        {

            var localVarPath = "/v2/products";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter.search", filterSearch)); // query parameter
            if (filterEanList != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "filter.eanList", filterEanList)); // query parameter
            if (filterMerchantProductNoList != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("multi", "filter.merchantProductNoList", filterMerchantProductNoList)); // query parameter
            if (filterPage != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "filter.page", filterPage)); // query parameter

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductGetByFilter", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<CollectionOfMerchantProductResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (CollectionOfMerchantProductResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(CollectionOfMerchantProductResponse)));
        }

        /// <summary>
        /// Get Product Retrieve a product based on the merchant reference.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>SingleOfMerchantProductResponse</returns>
        public SingleOfMerchantProductResponse ProductGetByMerchantProductNo (string merchantProductNo)
        {
             ApiResponse<SingleOfMerchantProductResponse> localVarResponse = ProductGetByMerchantProductNoWithHttpInfo(merchantProductNo);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get Product Retrieve a product based on the merchant reference.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>ApiResponse of SingleOfMerchantProductResponse</returns>
        public ApiResponse< SingleOfMerchantProductResponse > ProductGetByMerchantProductNoWithHttpInfo (string merchantProductNo)
        {
            // verify the required parameter 'merchantProductNo' is set
            if (merchantProductNo == null)
                throw new ApiException(400, "Missing required parameter 'merchantProductNo' when calling ProductApi->ProductGetByMerchantProductNo");

            var localVarPath = "/v2/products/{merchantProductNo}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (merchantProductNo != null) localVarPathParams.Add("merchantProductNo", this.Configuration.ApiClient.ParameterToString(merchantProductNo)); // path parameter

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductGetByMerchantProductNo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SingleOfMerchantProductResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SingleOfMerchantProductResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SingleOfMerchantProductResponse)));
        }

        /// <summary>
        /// Get Product Retrieve a product based on the merchant reference.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of SingleOfMerchantProductResponse</returns>
        public async System.Threading.Tasks.Task<SingleOfMerchantProductResponse> ProductGetByMerchantProductNoAsync (string merchantProductNo)
        {
             ApiResponse<SingleOfMerchantProductResponse> localVarResponse = await ProductGetByMerchantProductNoAsyncWithHttpInfo(merchantProductNo);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get Product Retrieve a product based on the merchant reference.
        /// </summary>
        /// <exception cref="ChannelEngine.Merchant.ApiClient.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="merchantProductNo"></param>
        /// <returns>Task of ApiResponse (SingleOfMerchantProductResponse)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<SingleOfMerchantProductResponse>> ProductGetByMerchantProductNoAsyncWithHttpInfo (string merchantProductNo)
        {
            // verify the required parameter 'merchantProductNo' is set
            if (merchantProductNo == null)
                throw new ApiException(400, "Missing required parameter 'merchantProductNo' when calling ProductApi->ProductGetByMerchantProductNo");

            var localVarPath = "/v2/products/{merchantProductNo}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "text/plain",
                "application/json",
                "text/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (merchantProductNo != null) localVarPathParams.Add("merchantProductNo", this.Configuration.ApiClient.ParameterToString(merchantProductNo)); // path parameter

            // authentication (apikey) required
            if (!String.IsNullOrEmpty(this.Configuration.GetApiKeyWithPrefix("apikey")))
            {
                localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "apikey", this.Configuration.GetApiKeyWithPrefix("apikey")));
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProductGetByMerchantProductNo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<SingleOfMerchantProductResponse>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (SingleOfMerchantProductResponse) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(SingleOfMerchantProductResponse)));
        }

    }
}
